#' envdat_ex_occ <- envdat_ex[ , , occExample == 1] 
#' startparms(envdat_ex_occ)
#' 
#' @param envdat Environmental time series array 
#' @param pa Presence absence vector
#' @param parallel Parallelization strategy
#' optim_mll(envdat_ex, occExample)
#' 
optim_mll <- function(envdat, pa,  parallel = FALSE){
  
  
  envdat_ex_occ <- envdat[ , , pa == 1] 
  paramTable <-  startparms(envdat_ex_occ)
  
  
  list_of_rows <- split(paramTable, seq(nrow(paramTable)))
  list_of_rows <- Map(unlist, list_of_rows)
  
  f_gen <- function(envdat, pa)function(params){
    res <- ucminf::ucminf(par = params,
                         fn  = loglik_orthog_nd_unconstr,
                         envdat = envdat,
                         pa  = pa,
                         negative = TRUE,
                         num_threads = 4,
                         hessian = FALSE)

    output <- c(res$par, value = res$value, convergence = res$convergence )
  }
  
  f <- f_gen(envdat_pa)
  output <- f(list_of_rows[[1]])
  return(output)
  # 
  # suppressWarnings({
  #   
  #   res = ucminf::ucminf(par = params,
  #                        fn  = loglik_orthog_nd_unconstr,
  #                        envdat = envdat,
  #                        pa  = pa,
  #                        negative = TRUE,
  #                        num_threads = 4,
  #                        hessian = FALSE)
  #   
  #   output <- c(res$par, value = res$value, convergence = res$convergence )
  # })
  # 
 
  # 
  # if(parallel){
  #   
  #   future::plan(strategy = "multisession")
  #   res <- furrr::future_map_dfr(1:nsim, \(x) f(), .options = furrr::furrr_options(seed = TRUE))
  #   #res <- get(mat, envir = .GlobalEnv)
  # } else {
  #   res <- purrr::map_dfr(1:nsim, \(x) f(), .progress = TRUE )
  #   
  # }
  # 
  #return(list_of_rows)
}
