function (par, fn, gr = NULL, hess = NULL, lower = -Inf, upper = Inf, 
          method = c("Nelder-Mead", "BFGS"), itnmax = NULL, hessian = FALSE, 
          control = list(), ...) 
{
  fn1 <- function(par) fn(par, ...)
  gr1 <- if (!is.null(gr)) 
    function(par) gr(par, ...)
  he1 <- if (!is.null(hess)) 
    function(par) hess(par, ...)
  optcfg <- optimx.setup(par, fn1, gr1, he1, lower, upper, 
                         method, itnmax, hessian, control)
  if (optcfg$ctrl$starttests) {
    optchk <- optimx.check(par, optcfg$ufn, optcfg$ugr, optcfg$uhess, 
                           lower, upper, hessian, optcfg$ctrl, have.bounds = optcfg$have.bounds, 
                           usenumDeriv = optcfg$usenumDeriv)
  }
  optcfg$ctrl$have.bounds <- optcfg$have.bounds
  if (!is.null(control$trace) && control$trace > 1) {
    cat("optcfg:")
    print(optcfg)
  }
  ansout <- optimx.run(par, optcfg$ufn, optcfg$ugr, optcfg$uhess, 
                       lower, upper, optcfg$method, itnmax, hessian, optcfg$ctrl)
  details <- attr(ansout, "details")
  attr(ansout, "details") <- NULL
  if (optcfg$ctrl$maximize) {
    if (optcfg$ctrl$trace > 0) 
      cat("Reversing sign on objective, gradient, & hessian\n")
    ansout$value <- -ansout$value
    nlist <- dim(details)[[1]]
    for (i in 1:nlist) {
      details[[i, "ngatend"]] <- -details[[i, "ngatend"]]
      details[[i, "nhatend"]] <- -details[[i, "nhatend"]]
      details[[i, "hev"]] <- -details[[i, "hev"]]
    }
  }
  rownames(details) <- details[, "method"]
  ansout[, "kkt1"] <- as.logical(ansout[, "kkt1"])
  ansout[, "kkt2"] <- as.logical(ansout[, "kkt2"])
  answer <- structure(ansout, details = details, maximize = optcfg$ctrl$maximize, 
                      npar = optcfg$npar, follow.on = optcfg$ctrl$follow.on, 
                      class = c("optimx", "data.frame"))
  answer
  
  
###
  
  function (par, ufn, ugr, uhess, lower = -Inf, upper = Inf, hessian = FALSE, 
            ctrl, have.bounds = FALSE, usenumDeriv = FALSE) 
  {
    if (!is.null(dim(par))) 
      stop("Parameter should be a vector, not a matrix!", call. = FALSE)
    if (!is.vector(par)) {
      stop("The parameters are NOT in a vector")
    }
    npar <- length(par)
    optchk <- list()
    if (ctrl$starttests) {
      infeasible <- FALSE
      if (ctrl$trace > 0) 
        cat("Function has ", npar, " arguments\n")
      if (have.bounds) {
        if (length(lower) == 1) 
          lower <- rep(lower, npar)
        if (length(upper) == 1) 
          upper <- rep(upper, npar)
        bstate <- vector(mode = "character", length = npar)
        for (i in 1:npar) {
          if ((lower[i] <= par[i]) && (par[i] <= upper[i])) {
            bstate[i] <- " In Bounds "
          }
          else {
            infeasible <- TRUE
            if (lower[i] > par[i]) {
              bstate[i] <- " Out of Bounds LOW"
            }
            else {
              bstate[i] <- " Out of Bounds HIGH "
            }
          }
          if (ctrl$trace > 0) 
            cat("par[", i, "]: ", lower[i], "  <?", par[i], 
                "  <?", upper[i], "  ", bstate[i], "\n")
        }
        if (infeasible) {
          stop("Infeasible point, no further tests")
        }
      }
      firsttry <- try(finit <- ufn(par), silent = FALSE)
      if (inherits(firsttry, "try-error")) {
        infeasible <- TRUE
        stop("Cannot evaluate function at initial parameters")
      }
      if (!(is.vector(finit) && (length(finit) == 1)) || is.list(finit) || 
          is.matrix(finit) || is.array(finit) || !is.numeric(finit)) {
        stop("Function provided is not returning a scalar number")
      }
      if (is.infinite(finit) || is.na(finit)) {
        stop("Function returned is infinite or NA (non-computable)")
      }
    }
    if (ctrl$starttests) {
      optchk$grbad <- FALSE
      if (!is.null(ugr) && !usenumDeriv && !is.character(ugr)) {
        gname <- deparse(substitute(ugr))
        if (ctrl$trace > 0) 
          cat("Analytic gradient from function ", gname, 
              "\n\n")
        fval <- ufn(par)
        gn <- grad(func = ufn, x = par)
        ga <- ugr(par)
        teps <- (.Machine$double.eps)^(1/3)
        if (max(abs(gn - ga))/(1 + abs(fval)) >= teps) {
          stop("Gradient function might be wrong - check it! \n", 
               call. = FALSE)
          optchk$grbad <- TRUE
        }
      }
      else if (ctrl$trace > 0) 
        cat("Analytic gradient not made available.\n")
      optchk$hessbad <- FALSE
      if (!is.null(uhess) && !is.character(uhess)) {
        hname <- deparse(substitute(uhess))
        if (ctrl$trace > 0) 
          cat("Analytic hessian from function ", hname, 
              "\n\n")
        hn <- hessian(func = ufn, x = par)
        ha <- uhess(par)
        teps <- (.Machine$double.eps)^(1/3)
        if (max(abs(hn - ha))/(1 + abs(fval)) >= teps) 
          stop("Hessian function might be wrong - check it! \n", 
               call. = FALSE)
        optchk$hessbad <- TRUE
      }
      else if (ctrl$trace > 0) 
        cat("Analytic Hessian not made available.\n")
    }
    if (ctrl$starttests) {
      optchk$scalebad <- FALSE
      srat <- scalecheck(par, lower, upper, ctrl$dowarn)
      sratv <- c(srat$lpratio, srat$lbratio)
      if (max(sratv, na.rm = TRUE) > ctrl$scaletol) {
        warnstr <- "Parameters or bounds appear to have different scalings.\n  This can cause poor performance in optimization. \n  It is important for derivative free methods like BOBYQA, UOBYQA, NEWUOA."
        if (ctrl$dowarn) 
          warning(warnstr)
        optchk$scalebad <- TRUE
      }
      if (ctrl$trace > 0) {
        cat("Scale check -- log parameter ratio=", srat$lpratio, 
            "  log bounds ratio=", srat$lbratio, "\n")
      }
    }
    optchk
  }